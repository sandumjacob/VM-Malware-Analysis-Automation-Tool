import csv, os, numpy, threading
from scapy.all import *

# This works for now but I will probably need to 
# implement a storage cache to avoid rampant 
# memory usage
export_dir = os.path.abspath("/media/root/Data1/Projects/Research/data")
logged_packets = []
interface = 'wlan0'
t = AsyncSniffer(iface=interface)

def live_capture_for_packet_count(packetCount):
    sniff(iface=interface, prn= lambda x: log_packet(x), count=packetCount)

def recv_packet_callback(packet):
    print("Packet intercepted: \n%s" % (packet))
    log_packet(packet)

def async_packet_capture(stopcondition):
    t.start()
    while True:
        if stopcondition == False:
            t.stop()
            for result in t.results:
                log_packet(result)

def sync_packet_capture_for(seconds):
    t.start()
    time.sleep(seconds)
    t.stop()
    for result in t.results:
        log_packet(result)

def async_packet_capture_for(seconds, export, wipe):
    print("Capturing packets...")
    # This executes once seconds has passed
    def done():
        print("Done capturing packets")
        t.stop()
        for result in t.results:
            log_packet(result)
        if export:
            export_packet_log(True)

    timer = threading.Timer(seconds, done)
    t.start()
    timer.start()



def export_packet_log(wipe):
    print("Exporting packet logs")
    filename = "Capture: %s" % (time.strftime("%Y%m%d-%H%M%S"))
    export_path = os.path.join(export_dir, filename)
    wrpcap(export_path, logged_packets)
    if wipe == True:
        wipe_log()

def export_packet_log_with_name(filename, wipe):
    print("Exporting packet logs")
    print(logged_packets)
    export_path = os.path.join(export_dir, filename)
    wrpcap(export_path, logged_packets)
    if wipe == True:
        wipe_log()

def live_capture_with_callback_on_condition(condition):
    while condition:
        live_capture_with_callback(recv_packet_callback)

def live_capture_with_callback(callback):
    sniff(iface=interface, prn=callback)

# Automatically determines whether to cache or continue
# in memory
def log_packet(packet):
    logged_packets.append(packet)

# Wipe cache and memory
def wipe_log():
    logged_packets.clear()

# live_capture_with_callback_on_condition(True)
# export_packet_log("bar.pcap", wipe=False)

